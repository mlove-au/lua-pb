
package integer64;

// Variable length integers can use zigzag encoding to reduce space used
// to encode the value. From https://developers.google.com/protocol-buffers/docs/encoding

//  If you use int32 or int64 as the type for a negative number, the resulting 
//  varint is always ten bytes long â€“ it is, effectively, treated like a very large 
//  unsigned integer. If you use one of the signed types, the resulting varint
//  uses ZigZag encoding, which is much more efficient. 


message SignedVarint64
{
    // inefficent for negative numbers
    optional int64      int64_      =   1;

    // Fixed 8 byte
    optional sfixed64   sfixed64_   =   2;

    // efficent for negative numbers
    optional sint64     sint64_     =   3;
}

message UnsignedVarint64
{
    optional uint64     uint64_     =   1;
    optional fixed64    fixed64_    =   2;
}

